# Uses python3
import sys

"""
–í–≤–µ–¥–µ–Ω–∏–µ

–í–∞–º –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä,
–∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ —Ç—Ä–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ç–µ–∫—É—â–∏–º —á–∏—Å–ª–æ–º ùë•: 
—É–º–Ω–æ–∂–∏—Ç—å ùë• –Ω–∞ 2, —É–º–Ω–æ–∂–∏—Ç—å ùë• –Ω–∞ 3 –∏–ª–∏ –ø—Ä–∏–±–∞–≤–∏—Ç—å 1 –∫ ùë•. 
–í–∞—à–µ–π —Ü–µ–ª–∏ –¥–∞–Ω–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ùëõ, 
–Ω–∞–π–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —á–∏—Å–ª–∞ ùëõ, –Ω–∞—á–∏–Ω–∞—è —Å —á–∏—Å–ª–∞ 1. 

–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã

–¢–∞—Å–∫–∞

–£—á–∏—Ç—ã–≤–∞—è —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –≤—ã—á–∏—Å–ª–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —á–∏—Å–ª–∞ ùëõ, –Ω–∞—á–∏–Ω–∞—è —Å —á–∏—Å–ª–∞ 1. 

–§–æ—Ä–º–∞—Ç –∏–Ω–ø—É—Ç–∞
–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞ 1 ‚â§ ùëõ ‚â§ 10^6.

–§–æ—Ä–º–∞—Ç –æ—Ç–ø—É—Ç–∞
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π operations, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ 1. 
–í–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–µ –≤—ã–≤–µ–¥–∏—Ç–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —á–∏—Å–µ–ª. 
–¢–æ –µ—Å—Ç—å –≤–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ ùëé0, ùëé2, ..., ùëéùëò ‚àí 1 —Ç–∞–∫–∏–µ, 
—á—Ç–æ ùëé0 = 1, ùëéùëò ‚àí 1 = ùëõ –∏ –¥–ª—è –≤—Å–µ—Ö 0‚â§ùëñ <ùëò ‚àí 1 + 1 —Ä–∞–≤–Ω–æ –ª–∏–±–æ ùëéùëñ + 1 , 2ùëéùëñ –∏–ª–∏ 3ùëéùëñ. 
–ï—Å–ª–∏ —Ç–∞–∫–∏—Ö –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –º–Ω–æ–≥–æ, –≤—ã–≤–µ–¥–∏—Ç–µ –ª—é–±—É—é –∏–∑ –Ω–∏—Ö.  

–ü—Ä–∏–º–µ—Ä 1
5

3
1245
   1 2 3 4 5
1 |1|2|3|4|5|
2 |2|4|6| | |
3 | | | | | |


–ü—Ä–∏–º–µ—Ä 2
1

0
1

–ü—Ä–∏–º–µ—Ä 3
96234

14
1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234
"""


def new_sequence(n):
    count = [0] * (n + 1)
    count[1] = 1
    for i in range(2, n + 1):
        indices = [i - 1]
        if i % 2 == 0:
            indices.append(i // 2)
        if i % 3 == 0:
            indices.append(i // 3)

        min_hops = min([count[x] for x in indices])

        count[i] = min_hops + 1
    point = n
    optimal_seq = [point]
    while point != 1:
        candidates = [point - 1]
        if point % 2 == 0:
            candidates.append(point // 2)
        if point % 3 == 0:
            candidates.append(point // 3)

        point = min(
            [(c, count[c]) for c in candidates],
            key=lambda x: x[1]
        )[0]
        optimal_seq.append(point)

    return reversed(optimal_seq)


def optimal_sequence(n):
    sequence = []
    while n >= 1:
        sequence.append(n)
        if n % 3 == 0:
            n = n // 3
        elif n % 2 == 0:
            n = n // 2
        else:
            n = n - 1
    return reversed(sequence)


input = sys.stdin.read()
n = int(input)
sequence = list(new_sequence(n))
print(len(sequence) - 1)
for x in sequence:
    print(x, end=" ")
